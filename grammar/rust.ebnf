(*
   EBNF Grammar for Rust 1.75+

   Derived from: yaml/rust.yaml
   This grammar represents the official Rust 1.75 syntax with:
   - Brace-based block structure
   - Comprehensive type system with generics and lifetimes
   - Trait system and implementations
   - Ownership and borrowing rules
   - Module system and visibility
   - Macros and attributes
   - Advanced pattern matching
   - Async/await support
*)

(* ============================================================================
   1. LEXICAL TOKENS
   ============================================================================ *)

(* Keywords *)
keyword = "as" | "async" | "await" | "break" | "const" | "continue" | "crate"
         | "dyn" | "else" | "enum" | "extern" | "false" | "fn" | "for" | "if"
         | "impl" | "in" | "let" | "loop" | "match" | "mod" | "move" | "mut"
         | "pub" | "ref" | "return" | "self" | "Self" | "static" | "struct"
         | "super" | "trait" | "true" | "type" | "unsafe" | "use" | "where"
         | "while" | "abstract" | "become" | "box" | "do" | "final"
         | "macro" | "override" | "priv" | "typeof" | "unsized" | "virtual"
         | "yield" ;

(* Operators and delimiters *)
arithmetic_op = "+" | "-" | "*" | "/" | "%" ;
comparison_op = "==" | "!=" | "<" | ">" | "<=" | ">=" ;
logical_op = "&&" | "||" | "!" ;
bitwise_op = "&" | "|" | "^" | "!" | "<<" | ">>" ;
assignment_op = "=" | "+=" | "-=" | "*=" | "/=" | "%=" | "&=" | "|=" | "^="
              | "<<=" | ">>=" ;
other_op = "=>" | "->" | "::" | ".." | "..=" | "." | "," | ";" | ":" | "@"
         | "#" | "$" | "?" ;

operator = arithmetic_op | comparison_op | logical_op | bitwise_op
         | assignment_op | other_op ;

delimiter = "(" | ")" | "{" | "}" | "[" | "]" | "<" | ">" ;

(* Identifiers *)
identifier = ( "a".."z" | "A".."Z" | "_" ) ( "a".."z" | "A".."Z" | "0".."9" | "_" )* ;
keyword_identifier = "r#" identifier ;

(* Numeric literals *)
integer_literal = "0".."9"+ ( "_" "0".."9"+ )* ( "i8" | "i16" | "i32" | "i64" | "isize"
                                                 | "u8" | "u16" | "u32" | "u64" | "usize" )? ;
binary_literal = "0b" ( "0" | "1" ) ( "_" ( "0" | "1" ) )*
               ( "i8" | "i16" | "i32" | "i64" | "isize"
               | "u8" | "u16" | "u32" | "u64" | "usize" )? ;
octal_literal = "0o" ( "0".."7" ) ( "_" ( "0".."7" ) )*
              ( "i8" | "i16" | "i32" | "i64" | "isize"
              | "u8" | "u16" | "u32" | "u64" | "usize" )? ;
hex_literal = "0x" ( "0".."9" | "a".."f" | "A".."F" )+
            ( "_" ( "0".."9" | "a".."f" | "A".."F" ) )*
            ( "i8" | "i16" | "i32" | "i64" | "isize"
            | "u8" | "u16" | "u32" | "u64" | "usize" )? ;

float_literal = "0".."9"+ "." ( "0".."9"+ )? ( ( "e" | "E" ) ( "+" | "-" )? "0".."9"+ )?
              ( "f32" | "f64" )?
              | "0".."9"* "." "0".."9"+ ( ( "e" | "E" ) ( "+" | "-" )? "0".."9"+ )?
              ( "f32" | "f64" )? ;

number_literal = binary_literal | octal_literal | hex_literal | float_literal | integer_literal ;

(* String and character literals *)
string_literal = '"' ( !'"' | '\"' | '\\' _ )* '"'
               | "r" '"' ( ! '"' )* '"'
               | "r#" '"' ( ! '"' )* '"' "#"+ ;

char_literal = "'" ( !"'" | "\'" | "\\" ) "'" ;

byte_string = "b\"" ( !'"' | '\"' )* '"'
            | "br\"" ( ! '"' )* '"' ;

(* Boolean and lifetime *)
boolean_literal = "true" | "false" ;
lifetime = "'" identifier ;

literal = number_literal | string_literal | char_literal | byte_string
        | boolean_literal ;

(* Comments *)
line_comment = "//" ( ! "\n" )* "\n" ;
block_comment = "/*" ( ! "*/" )* "*/" ;

(* Attributes *)
attribute = "#" "[" meta_item "]" | "#!" "[" meta_item "]" ;
meta_item = identifier ("=" literal | "(" meta_item_list ")")? ;
meta_item_list = meta_item ("," meta_item)* ;

(* ============================================================================
   2. STRUCTURAL RULES
   ============================================================================ *)

program = item* EOF ;

block = "{" statement* "}" ;

crate_module = item* EOF ;

(* ============================================================================
   3. ITEMS AND DECLARATIONS
   ============================================================================ *)

item = attribute* item_content ;

item_content = visibility? (
                module_declaration
              | extern_crate
              | use_declaration
              | function_item
              | type_alias
              | struct_item
              | enum_item
              | union_item
              | const_item
              | static_item
              | trait_item
              | trait_impl
              | impl_block
              | extern_block
              | macro_definition ) ;

visibility = "pub" ("(" ( "crate" | "self" | "super" | "in" path ) ")")? ;

(* Module declarations *)
module_declaration = "mod" identifier (";" | "{" item* "}") ;

extern_crate = "extern" "crate" identifier ("as" identifier)? ";" ;

(* Use declarations *)
use_declaration = "use" use_path ";" ;
use_path = path ("::" "*" | "::" "{" use_list "}") ;
use_list = use_path ("," use_path)* ;
path = "::"? segment ("::" segment)* ;
segment = super | self_seg | crate_seg | identifier ;
super = "super" ;
self_seg = "self" ;
crate_seg = "crate" ;

(* Type aliases *)
type_alias = "type" identifier generic_params? ("=" type_expression)? ";" ;

(* Function items *)
function_item = "async"? "unsafe"? "fn" identifier generic_params?
               "(" parameter_list? ")" where_clause? return_type? block ;
parameter_list = parameter ("," parameter)* ;
parameter = attribute* ("&" lifetime? mutability?)? identifier ":" type_expression
          | attribute* "..." ;
return_type = "->" type_expression ;
where_clause = "where" (lifetime ":" lifetime_bounds ",")* (type_expression ":" trait_bounds ",")* ;

(* Struct items *)
struct_item = "struct" identifier generic_params? where_clause?
            (struct_body | ";") ;
struct_body = "{" (attribute* visibility? identifier ":" type_expression
                    ("," attribute* visibility? identifier ":" type_expression)*)? "}" ;

(* Enum items *)
enum_item = "enum" identifier generic_params? where_clause? "{"
           (enum_variant ("," enum_variant)*)? "}" ;
enum_variant = attribute* identifier (enum_variant_data)? ;
enum_variant_data = "(" (type_expression ("," type_expression)*)? ")"
                  | "{" (identifier ":" type_expression ("," identifier ":" type_expression)*)? "}" ;

(* Union items *)
union_item = "union" identifier generic_params? where_clause? "{"
            (attribute* visibility? identifier ":" type_expression ("," ...)?)? "}" ;

(* Const and static items *)
const_item = "const" identifier ":" type_expression "=" expression ";" ;
static_item = "static" mutability? identifier ":" type_expression "=" expression ";" ;
mutability = "mut" ;

(* Trait items *)
trait_item = attribute* "unsafe"? "trait" identifier generic_params?
            (":" trait_bounds)? where_clause? "{"
            (trait_member)* "}" ;
trait_member = attribute* visibility? (
              type_item
            | const_item
            | function_item ) ;
trait_bounds = trait_bound ("+" trait_bound)* ;
trait_bound = ("?" )? lifetime | ("?")? path ;

(* Trait implementations *)
trait_impl = attribute* "unsafe"? "impl" generic_params?
            trait_ref "for" type_expression where_clause? "{"
            (impl_item)* "}" ;
impl_item = attribute* visibility? (
           const_item
         | type_item
         | function_item ) ;

(* Impl blocks *)
impl_block = attribute* "unsafe"? "impl" generic_params?
            type_expression where_clause? "{" (impl_item)* "}" ;

(* Extern blocks *)
extern_block = "extern" string_literal? "{" (attribute* visibility? "fn" identifier
              "(" parameter_list? ")" where_clause? return_type? ";")* "}" ;

(* Macro definitions *)
macro_definition = "macro_rules" identifier "{" macro_rule* "}" ;
macro_rule = pattern "=>" expression_or_block ";" ;

(* ============================================================================
   4. STATEMENTS
   ============================================================================ *)

statement = expression_statement | item | let_statement ;

let_statement = attribute* "let" pattern (":" type_expression)? ("=" expression)? ";" ;

expression_statement = expression (";" )? ;

(* ============================================================================
   5. PATTERNS
   ============================================================================ *)

pattern = pattern_or ;

pattern_or = pattern_and ("|" pattern_and)* ;

pattern_and = pattern_range ("&" pattern_range)* ;

pattern_range = pattern_binding
              | pattern_literal
              | pattern_range_bound ;

pattern_binding = "ref"? mutability? identifier ("@" pattern_binding)? ;

pattern_literal = literal | "-" number_literal | "true" | "false" ;

pattern_range_bound = pattern_range_expr ".." pattern_range_expr
                    | pattern_range_expr "..=" pattern_range_expr ;

pattern_range_expr = pattern_literal | identifier ;

(* ============================================================================
   6. EXPRESSIONS (ordered by precedence: lowest to highest)
   ============================================================================ *)

expression = assignment_expression ;

(* Assignment (right-associative) *)
assignment_expression = logical_or_expression
                       (assignment_op assignment_expression)? ;

(* Logical OR *)
logical_or_expression = logical_and_expression ("||" logical_and_expression)* ;

(* Logical AND *)
logical_and_expression = equality_expression ("&&" equality_expression)* ;

(* Equality *)
equality_expression = relational_expression
                    (("==" | "!=") relational_expression)* ;

(* Relational *)
relational_expression = bitwise_or_expression
                      (("<" | ">" | "<=" | ">=") bitwise_or_expression)* ;

(* Bitwise OR *)
bitwise_or_expression = bitwise_xor_expression ("|" bitwise_xor_expression)* ;

(* Bitwise XOR *)
bitwise_xor_expression = bitwise_and_expression ("^" bitwise_and_expression)* ;

(* Bitwise AND *)
bitwise_and_expression = shift_expression ("&" shift_expression)* ;

(* Shift *)
shift_expression = additive_expression
                 (("<<" | ">>") additive_expression)* ;

(* Additive *)
additive_expression = multiplicative_expression
                    (("+" | "-") multiplicative_expression)* ;

(* Multiplicative *)
multiplicative_expression = unary_expression
                           (("*" | "/" | "%") unary_expression)* ;

(* Unary *)
unary_expression = ("!" | "-" | "*" | "&" mutability? | "await")? postfix_expression ;

(* Postfix (method calls, field access, indexing) *)
postfix_expression = primary_expression
                   (postfix_op)* ;

postfix_op = function_call_args | field_access | index_access | try_expr ;

function_call_args = "(" argument_list? ")" ;
argument_list = expression ("," expression)* ;

field_access = "." identifier | "." integer_literal ;

index_access = "[" expression "]" ;

try_expr = "?" ;

(* Primary expressions *)
primary_expression = literal
                   | identifier
                   | path
                   | grouping
                   | tuple_expression
                   | array_expression
                   | block_expression
                   | unsafe_block
                   | if_expression
                   | match_expression
                   | loop_expression
                   | while_expression
                   | for_expression
                   | closure_expression
                   | break_expression
                   | continue_expression
                   | return_expression
                   | macro_invocation ;

grouping = "(" expression? ")" ;

tuple_expression = "(" expression ("," expression)* ")" ;

array_expression = "[" (expression ("," expression)*)? "]"
                 | "[" expression ";" expression "]" ;

block_expression = "{" statement* expression? "}" ;

unsafe_block = "unsafe" block_expression ;

if_expression = "if" expression block_expression ("else" (block_expression | if_expression))? ;

match_expression = "match" expression "{" (match_arm)* "}" ;
match_arm = attribute* pattern ("if" expression)? "=>" expression "," ;

loop_expression = "loop" block_expression ;

while_expression = "while" expression block_expression ;

for_expression = "for" pattern "in" expression block_expression ;

closure_expression = move? "|" parameter_list? "|" expression ;
move = "move" ;

break_expression = "break" lifetime? expression? ;

continue_expression = "continue" lifetime? ;

return_expression = "return" expression? ;

macro_invocation = path "!" identifier? "(" expression ")" ;

(* ============================================================================
   7. TYPE EXPRESSIONS
   ============================================================================ *)

type_expression = type_union ;

type_union = type_impl_trait ("|" type_impl_trait)* ;

type_impl_trait = trait_object_type | type_path ;

trait_object_type = "dyn" trait_bound ("+" trait_bound)* ;

type_path = "::"? type_segment ("::" type_segment)* ;

type_segment = identifier ("<" generic_arguments ">")? ;

generic_arguments = generic_argument ("," generic_argument)* ;

generic_argument = lifetime | type_expression ;

(* Type constructors *)
reference_type = "&" lifetime? mutability? type_expression ;

pointer_type = "*const" type_expression | "*mut" type_expression ;

slice_type = "[" type_expression "]" ;

array_type = "[" type_expression ";" expression "]" ;

tuple_type = "(" (type_expression ("," type_expression)*)? ")" ;

function_type = "fn" "(" (type_expression ("," type_expression)*)? ")"
              "->" type_expression ;

impl_trait_type = "impl" trait_bound ("+" trait_bound)* ;

(* Generic parameters *)
generic_params = "<" generic_param ("," generic_param)* ">" ;

generic_param = attribute* lifetime | attribute* identifier
              (":" trait_bounds)?
              ("=" type_expression)? ;

(* Lifetime parameters *)
lifetime_bounds = lifetime ("+" lifetime)* ;

(* ============================================================================
   8. SPECIAL RULES
   ============================================================================ *)

EOF = end_of_file ;

(* ============================================================================
   9. NOTES ON SPECIAL CONSTRUCTS
   ============================================================================ *)

(*
   Brace-based block structure:
   - Blocks enclosed in { }
   - Statements terminated with ;
   - Expressions as last statement (no ;) return value

   Ownership & borrowing:
   - & creates immutable borrow
   - &mut creates mutable borrow
   - Lifetimes: 'a, 'b, etc.

   Generic types:
   - Type parameters: T, U, V
   - Trait bounds: T: Trait
   - Associated types: T::AssociatedType

   Pattern matching:
   - match expressions for exhaustive matching
   - Patterns: literals, bindings, structures, slices

   Macros:
   - Declarative macros: macro_rules!
   - Procedural macros with #[derive]
   - Macro invocation: macro!(...)

   Attributes:
   - Outer: #[attribute]
   - Inner: #![attribute]
   - Can decorate items, expressions, etc.

   Async/await:
   - async fn defines async functions
   - await expression suspends execution
   - Requires async context

   Safety:
   - unsafe blocks for unsafe operations
   - Requires explicit unsafe keyword
   - Memory safety guaranteed outside unsafe

   Modules:
   - mod name { ... } inline modules
   - pub mod name; declares module file
   - use path::to::item;

   Visibility:
   - pub (public)
   - pub(crate) (crate-public)
   - pub(super) (parent module public)
   - private (default)
*)
