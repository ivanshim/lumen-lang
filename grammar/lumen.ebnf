(*
   EBNF Grammar for Lumen Language v2.2

   Derived from: yaml/lumen.yaml
   This grammar represents the syntactic structure of Lumen,
   an indentation-based language emphasizing semantic clarity and minimalism.

   Authority: This grammar is the authoritative specification of Lumen syntax.
   When this grammar and implementation diverge, the grammar is authoritative.

   Conventions:
   - Lowercase with underscores: nonterminals
   - UPPERCASE or quoted: terminals
   - Operators ordered by precedence (lowest to highest)
   - Indentation-based block structure (INDENT/DEDENT mark blocks)
   - Comments: Single-line only, marked with # to end of line
*)

(* ============================================================================
   1. LEXICAL TOKENS AND LITERALS
   ============================================================================ *)

(* Keywords *)
keyword = "let" | "mut" | "if" | "else" | "while" | "for" | "until" | "in"
         | "break" | "continue" | "return" | "fn" | "extern"
         | "and" | "or" | "not" | "print" | "true" | "false" | "none" | "type" ;

(* Reserved keywords (not yet implemented) *)
reserved_keyword = "match" | "case" | "struct" | "enum" | "trait" ;

(* Operators and delimiters *)
arithmetic_op = "+" | "-" | "*" | "/" | "%" | "**" ;
comparison_op = "==" | "!=" | "<" | ">" | "<=" | ">=" ;
logical_op = "and" | "or" | "not" ;
assignment_op = "=" ;
pipe_op = "|>" ;
range_op = ".." ;
type_arrow = "->" ;

operator = arithmetic_op | comparison_op | logical_op | assignment_op
         | pipe_op | range_op | type_arrow ;

delimiter = "(" | ")" | "{" | "}" | "[" | "]" | "," | ";" | ":" | "." ;

(* Identifiers *)
identifier = ( "a".."z" | "A".."Z" | "_" ) ( "a".."z" | "A".."Z" | "0".."9" | "_" )* ;

(* Literals *)
integer_literal = "0".."9"+ ;
float_literal = "0".."9"+ "." "0".."9"+ ;
number_literal = float_literal | integer_literal ;

string_literal = '"' ( !'"' | '\"' )* '"' ;

boolean_literal = "true" | "false" ;
none_literal = "none" ;

literal = number_literal | string_literal | boolean_literal | none_literal ;

(* Comments *)
comment = "#" ( ! "\n" )* "\n" ;

(* Whitespace *)
whitespace = " " | "\t" ;


(* ============================================================================
   2. STRUCTURAL RULES
   ============================================================================ *)

program = statement* EOF ;

(* Indentation-based blocks *)
block = INDENT statement+ DEDENT ;

(* Statements *)
statement = variable_binding | assignment | if_statement | while_loop
          | for_loop | until_loop | break_statement | continue_statement
          | return_statement | function_definition | expression_statement ;

(* ============================================================================
   3. OPERATORS (ordered by precedence: lowest to highest)
   ============================================================================ *)

(* Precedence levels in Lumen:
   0.5 - pipe (|>)
   1   - assignment (=)
   2   - logical OR (or)
   3   - logical AND (and)
   4   - comparison (==, !=, <, >, <=, >=)
   5   - additive (+, -)
   6   - multiplicative (*, /, %)
   7   - exponentiation (**), unary (-, not)
   Range (.) - between comparison and additive
*)

(* ============================================================================
   4. STATEMENTS
   ============================================================================ *)

(* Variable binding *)
variable_binding = "let" mutability? identifier type_annotation? "=" expression ;
mutability = "mut" ;

(* Assignment *)
assignment = identifier "=" expression ;

(* If statement *)
if_statement = "if" expression block ("else" block)? ;

(* While loop *)
while_loop = "while" expression block ;

(* For loop: for x in iterable NEWLINE INDENT block DEDENT *)
for_loop = "for" identifier "in" expression block ;

(* Until loop: post-condition loop *)
until_loop = "until" expression block ;

(* Break and continue *)
break_statement = "break" ;
continue_statement = "continue" ;

(* Return statement *)
return_statement = "return" expression? ;

(* Function definition with parameters and optional return type annotation *)
function_definition = "fn" identifier "(" parameter_list? ")"
                     return_type_annotation? block ;
parameter_list = identifier type_annotation? ("," identifier type_annotation?)* ;
return_type_annotation = "->" type_expression ;

(* Expression statement *)
expression_statement = expression ;

(* ============================================================================
   5. EXPRESSIONS (ordered by precedence)
   ============================================================================ *)

(* Lowest precedence: pipe operator *)
expression = pipe_expression ;

pipe_expression = assignment_expression (pipe_op assignment_expression)* ;

(* Assignment expression (right-associative) *)
assignment_expression = logical_or_expression ("=" assignment_expression)? ;

(* Logical OR (left-associative) *)
logical_or_expression = logical_and_expression ("or" logical_and_expression)* ;

(* Logical AND (left-associative) *)
logical_and_expression = comparison_expression ("and" comparison_expression)* ;

(* Range expressions (between comparison and arithmetic) *)
range_expression = additive_expression (range_op additive_expression)? ;

(* Comparison (left-associative) *)
comparison_expression = range_expression (comparison_op range_expression)* ;

(* Additive (left-associative) *)
additive_expression = multiplicative_expression
                    (("+" | "-") multiplicative_expression)* ;

(* Multiplicative (left-associative) *)
multiplicative_expression = exponentiation_expression
                           (("*" | "/" | "%") exponentiation_expression)* ;

(* Exponentiation (right-associative) *)
exponentiation_expression = unary_expression ("**" exponentiation_expression)? ;

(* Unary operators (prefix) *)
unary_expression = ("-" | "not")? postfix_expression ;

(* Postfix operations (function calls, indexing) *)
postfix_expression = primary_expression
                   (function_call_args | index_access)* ;

function_call_args = "(" argument_list? ")" ;
argument_list = expression ("," expression)* ;

index_access = "[" expression "]" ;

(* Primary expressions *)
primary_expression = literal
                   | identifier
                   | function_call
                   | grouping
                   | tuple_literal ;

function_call = identifier "(" argument_list? ")" ;

grouping = "(" expression ")" ;

(* Tuple literal (heterogeneous collection) *)
tuple_literal = "(" expression ("," expression)* ")" ;

(* ============================================================================
   6. TYPE ANNOTATIONS (Optional)
   ============================================================================ *)

type_annotation = ":" type_expression ;

type_expression = primitive_type
                | composite_type
                | function_type ;

(* Primitive types *)
primitive_type = "number" | "string" | "boolean" | "none" ;

(* Composite types *)
composite_type = tuple_type | option_type | result_type ;

tuple_type = "(" type_expression ("," type_expression)* ")" ;
option_type = "Option[" type_expression "]" ;
result_type = "Result[" type_expression "," type_expression "]" ;

(* Function types *)
function_type = "fn" "(" (type_expression ("," type_expression)*)? ")"
               "->" type_expression ;

(* ============================================================================
   7. SPECIAL RULES
   ============================================================================ *)

(* Extern declarations *)
extern_declaration = "extern" identifier type_annotation? ;

(* Type aliases (reserved) *)
type_alias = "type" identifier "=" type_expression ;

(* EOF marker *)
EOF = end_of_file ;

(* ============================================================================
   8. NOTES ON SPECIAL CONSTRUCTS
   ============================================================================ *)

(*
   Indentation-based structure:
   - Indentation (4 spaces) introduces a block
   - INDENT token marks block start
   - DEDENT token marks block end
   - Newlines are statement terminators (unless escaped with backslash)
   - Semicolons can also terminate statements

   Example:
   ```
   if x > 5
       print(x)
   else
       print("small")
   ```

   Short-circuit evaluation:
   - "and" evaluates right operand only if left is true
   - "or" evaluates right operand only if left is false

   Assignment:
   - Can only assign to variables bound with "let" or "let mut"
   - Multiple assignment patterns deferred to future version

   Function definitions and calls:
   - Syntax: fn name(param1, param2, ...) [-> ReturnType] NEWLINE INDENT statements DEDENT
   - Parameters can have optional type annotations: name: Type
   - Return type annotation is optional: -> Type
   - Arguments are evaluated left to right
   - Functions return value of last expression (implicit return)
   - Explicit return statement available for early exit
   - Example: fn add(a: number, b: number) -> number
                a + b

   Range expressions:
   - Syntax: start..end
   - Half-open range [start, end)
   - Example: for i in 0..10 iterates i from 0 to 9

   Comments:
   - Syntax: # comment text to end of line
   - Single-line comments only; block comments not supported
   - Comments are ignored during parsing

   VALUE PROJECTIONS (Design Principle):
   ======================================
   In Lumen, a variable binds to ONE semantic value.
   That value may support multiple coherent projections, selected by usage.

   Key principle: Usage selects a projection; identity remains constant.
   This is NOT type casting or coercion.

   Projection Examples:
   - A Range value (e.g., 0..10) admits:
     * Iteration projection (for i in 0..10)
     * Display projection (print(0..10))
     * These are two ways of observing the same semantic Range object

   - System-provided values like ARGS (future feature) will admit:
     * Sequence projection (for arg in ARGS)
     * Indexing projection (ARGS[0])
     * Length projection (extern("length", ARGS))
     * Display projection (print(ARGS))

   Implementation Rules:
   - Operations (iteration, indexing, printing, length) select projections
   - Assigning a value (x = expr) binds the semantic object
   - Projections are lossless and coherent (no information loss)
   - No explicit cast syntax is used or needed
   - Adding new projections must not invalidate existing ones

   Resolution by Context:
   - The operation (for, [], print, extern) determines which projection is used
   - The grammar does not change; projections are semantic, not syntactic
   - Different operations may project different aspects of the same value
*)

