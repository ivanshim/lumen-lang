================================================================================
LUMEN-LANG: LANGUAGE-AGNOSTIC FRAMEWORK ARCHITECTURE
================================================================================

This document describes the directory structure for the language-agnostic
interpreter framework and language implementations.

================================================================================
DIRECTORY STRUCTURE
================================================================================

lumen-lang/
│
├── src/                                 # Binary entry point and shared schema
│   ├── main.rs                          # CLI for selecting kernel/language
│   └── schema/                          # Common argument/operator models
│
├── src_stream/                          # STREAM (procedural) KERNEL
│   ├── kernel/                          # Lexer, parser, registry, runtime eval
│   │   └── runtime/                     # Stream runtime primitives
│   ├── languages/                       # Stream language implementations
│   │   ├── lumen/
│   │   ├── mini_rust/
│   │   └── mini_python/
│   ├── schema/                          # Stream AST and operator schema
│   └── docs/                            # Stream kernel documentation
│
├── src_microcode/                       # MICROCODE (data-driven) KERNEL
│   ├── kernel/                          # Ingest → reduce → execute pipeline
│   ├── runtime/                         # Runtime glue for microcode engine
│   ├── languages/                       # Microcode language definitions
│   │   ├── lumen/
│   │   ├── mini_rust/
│   │   ├── mini_python/
│   │   └── alien_lang/
│   └── schema/                          # Microcode schema definitions
│
├── examples/                            # Sample programs (lumen, mini-rust, mini-python)
├── archive/                             # Inactive or experimental language tracks
├── README_LANGUAGES.md                  # Cross-language design notes
├── MICROCODE_ARCHITECTURE.md            # Microcode kernel overview
├── VERSION_HISTORY.md                   # Release notes and changelog
├── Cargo.toml
├── README.md                            # Project overview
└── DIR_STRUCTURE.txt                    # This file

================================================================================
KERNELS vs LANGUAGE MODULES
================================================================================

KERNEL TRACKS (src_stream/, src_microcode/):
  - Contain language-agnostic infrastructure
  - Stream kernel: procedural parsing/evaluation pipeline with direct AST execution
  - Microcode kernel: data-driven ingest → reduce → execute model
  - Each kernel ships with its own schema, runtime, and docs folders

LANGUAGE MODULES (src_stream/languages/, src_microcode/languages/):
  - Implement syntax/semantics for each supported language
  - Register tokens, operators, precedence, and language-specific primitives
  - Provide examples and (where applicable) documentation per language

================================================================================
KEY DESIGN PRINCIPLES
================================================================================

1. KERNEL AGNOSTICISM:
   - Kernels stay neutral regarding keywords or operators
   - All syntax/semantics live in language modules
   - Stream and microcode kernels expose different execution models while sharing the neutrality principle

2. MODULAR FEATURES:
   - Each language feature (statement, expression) is independent
   - Features register themselves with the framework registry
   - Features can be enabled/disabled by commenting out registrations

3. LANGUAGE SWAPPABLE:
   - Switching languages is handled in src/main.rs via CLI flags
   - Both kernels can host multiple languages without changing kernel code

================================================================================
ADDING A NEW LANGUAGE
================================================================================

To add a new language:

1. Create language folders under each kernel (e.g., src_stream/languages/your_lang/ and src_microcode/languages/your_lang/)
2. Add dispatcher/registration files to wire tokens, operators, and runtime handlers
3. Implement language features using the kernel's schema and runtime traits
4. Update src/main.rs CLI mapping if new file extensions or language names are introduced
5. Provide docs and examples to demonstrate the new language

The kernel layers remain untouched when adding languages; all semantics live in language modules.


