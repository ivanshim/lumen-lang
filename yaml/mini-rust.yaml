# Mini-Rust Language Schema (YAML)
# Pure declarative data for Mini-Rust
# All parsing and execution is handled by the microcode kernel

name: mini_rust
version: 1.0

# LEXICAL RULES
# =============

keywords:
  - if
  - else
  - while
  - for
  - let
  - mut
  - fn
  - return
  - loop
  - break
  - continue
  - match
  - true
  - false
  - print
  - in
  - println

# Multi-character lexemes (sorted by length descending for maximal-munch)
multichar_lexemes:
  - "=="
  - "!="
  - "<="
  - ">="
  - "=>"
  - "::"
  - "->"
  - "+="
  - "-="
  - "*="
  - "/="

# Characters that split tokens
split_chars:
  - " "
  - "\t"
  - "\n"
  - "{"
  - "}"
  - "("
  - ")"
  - "["
  - "]"
  - ","
  - ";"
  - ":"
  - "."
  - "&"

# STRUCTURAL RULES
# ================

structure:
  # Indentation mode: Rust uses braces, not indentation
  indentation: none

  # Newline behavior: Rust doesn't require newlines for statements
  newline_behavior: ignored

  # EOF handling
  eof_handling: none

  # Block delimiters (C-like with braces)
  block_open: "{"
  block_close: "}"

  # Statement terminators
  statement_terminators:
    - ";"

# OPERATORS
# =========

operators:
  # Binary operators
  binary:
    # Arithmetic (precedence 5-6)
    "+":
      precedence: 5
      associativity: left
      name: addition
    "-":
      precedence: 5
      associativity: left
      name: subtraction
    "*":
      precedence: 6
      associativity: left
      name: multiplication
    "/":
      precedence: 6
      associativity: left
      name: division
    "%":
      precedence: 6
      associativity: left
      name: modulo

    # Bitwise (precedence 5-6)
    "&":
      precedence: 5
      associativity: left
      name: bitwise_and
    "|":
      precedence: 4
      associativity: left
      name: bitwise_or
    "^":
      precedence: 4
      associativity: left
      name: bitwise_xor
    "<<":
      precedence: 5
      associativity: left
      name: shift_left
    ">>":
      precedence: 5
      associativity: left
      name: shift_right

    # Comparison (precedence 3-4)
    "==":
      precedence: 3
      associativity: left
      name: equal
    "!=":
      precedence: 3
      associativity: left
      name: not_equal
    "<":
      precedence: 3
      associativity: left
      name: less_than
    ">":
      precedence: 3
      associativity: left
      name: greater_than
    "<=":
      precedence: 3
      associativity: left
      name: less_equal
    ">=":
      precedence: 3
      associativity: left
      name: greater_equal

    # Logical (precedence 1-2)
    "&&":
      precedence: 2
      associativity: left
      name: logical_and
    "||":
      precedence: 1
      associativity: left
      name: logical_or

    # Assignment (precedence 0)
    "=":
      precedence: 0
      associativity: right
      name: assign
    "+=":
      precedence: 0
      associativity: right
      name: add_assign
    "-=":
      precedence: 0
      associativity: right
      name: sub_assign
    "*=":
      precedence: 0
      associativity: right
      name: mul_assign
    "/=":
      precedence: 0
      associativity: right
      name: div_assign

    # Range (precedence 7)
    "..":
      precedence: 7
      associativity: right
      name: range

  # Unary operators
  unary:
    "!":
      precedence: 8
      position: prefix
      name: logical_not
    "-":
      precedence: 8
      position: prefix
      name: negate
    "&":
      precedence: 8
      position: prefix
      name: reference
    "*":
      precedence: 8
      position: prefix
      name: dereference

# STATEMENTS
# ==========

statements:
  let_binding:
    description: "Let binding (variable declaration)"
    pattern: [keyword, identifier, optional(keyword, "=", expression), ";"]
    fields:
      - keyword: let
      - name: identifier
      - mut_keyword: mut
      - value: expression
    primitive: assign

  assignment:
    description: "Assignment to variable"
    pattern: [identifier, "=", expression, ";"]
    fields:
      - variable: name
      - operator: "="
      - value: expression
    primitive: assign

  if_statement:
    description: "If-else conditional"
    pattern: [keyword, expression, block, optional(keyword, block)]
    fields:
      - keyword: if
      - condition: expression
      - then_block: block
      - else_keyword: else
      - else_block: block
    primitive: conditional

  while_loop:
    description: "While loop"
    pattern: [keyword, expression, block]
    fields:
      - keyword: while
      - condition: expression
      - body: block
    primitive: loop

  for_loop:
    description: "For loop over range"
    pattern: [keyword, identifier, "in", expression, block]
    fields:
      - keyword: for
      - variable: identifier
      - in_keyword: in
      - iterable: expression
      - body: block
    primitive: loop

  loop_statement:
    description: "Infinite loop"
    pattern: [keyword, block]
    fields:
      - keyword: loop
      - body: block
    primitive: loop

  break_statement:
    description: "Break from loop"
    pattern: [keyword, ";"]
    fields:
      - keyword: break
    primitive: jump

  continue_statement:
    description: "Continue loop iteration"
    pattern: [keyword, ";"]
    fields:
      - keyword: continue
    primitive: jump

  return_statement:
    description: "Return from function"
    pattern: [keyword, optional(expression), ";"]
    fields:
      - keyword: return
      - value: expression
    primitive: return

  function_def:
    description: "Function definition"
    pattern: [keyword, identifier, "(", params, ")", optional("->", type), block]
    fields:
      - keyword: fn
      - name: identifier
      - params: parameter_list
      - return_type: type
      - body: block
    primitive: function_def

  print_macro:
    description: "Print macro invocation"
    pattern: [identifier, "!", "(", args, ")", ";"]
    fields:
      - macro: print
      - arguments: expression_list
    primitive: call

# EXPRESSION TYPES
# ================

expressions:
  literal:
    - number: "0-9, including decimals"
    - string: "\"...\""
    - boolean: "true, false"
    - char: "'c'"

  identifier:
    - pattern: "[a-zA-Z_][a-zA-Z0-9_]*"
    - description: "Variable name"

  function_call:
    - function: "identifier"
    - args: "expression_list"
    - syntax: "function(arg1, arg2)"

  method_call:
    - object: "expression"
    - method: "identifier"
    - syntax: "object.method(args)"

  indexing:
    - object: "expression"
    - index: "expression"
    - syntax: "object[index]"

  range:
    - start: "expression"
    - end: "expression"
    - syntax: "start..end"

  closure:
    - params: "parameter_list"
    - body: "block_or_expression"
    - syntax: "|x| x + 1"

  grouping:
    - open: "("
    - close: ")"
    - content: "expression"

# VALUE TYPES
# ===========

values:
  integer:
    description: "Signed integer"
    types:
      - i8: "8-bit"
      - i16: "16-bit"
      - i32: "32-bit"
      - i64: "64-bit"
      - isize: "Pointer-sized"

  unsigned:
    description: "Unsigned integer"
    types:
      - u8: "8-bit"
      - u16: "16-bit"
      - u32: "32-bit"
      - u64: "64-bit"
      - usize: "Pointer-sized"

  float:
    description: "Floating-point number"
    types:
      - f32: "32-bit IEEE 754"
      - f64: "64-bit IEEE 754"

  boolean:
    description: "true or false"
    values:
      - true
      - false

  string:
    description: "Owned string"
    syntax: "\"hello world\""

  str:
    description: "String slice (borrowed)"
    syntax: "&\"hello\""

  char:
    description: "Single character"
    syntax: "'a'"

  tuple:
    description: "Fixed-size heterogeneous collection"
    syntax: "(1, \"hello\", true)"

  array:
    description: "Fixed-size homogeneous collection"
    syntax: "[1, 2, 3, 4, 5]"

  option:
    description: "Optional value"
    values:
      - Some: "Value present"
      - None: "No value"

  result:
    description: "Result of fallible operation"
    values:
      - Ok: "Success"
      - Err: "Error"
