// src_lumen/structure/structural.rs
//
// Lumen structural tokens and indentation processing.
// Handles Python-style indentation: 4-space indents, INDENT/DEDENT tokens.
// Completely language-specific - registers all structural tokens here.

use crate::framework::lexer::{Token, SpannedToken};
use crate::framework::parser::StructuralTokens;
use crate::framework::registry::{LumenResult, Registry};

// --------------------
// Lumen Token Definitions
// --------------------

// Grouping
pub const LPAREN: &str = "LPAREN";
pub const RPAREN: &str = "RPAREN";

// Layout (Python-style indentation)
pub const NEWLINE: &str = "NEWLINE";
pub const INDENT: &str = "INDENT";
pub const DEDENT: &str = "DEDENT";

// End of file
pub const EOF: &str = "EOF";

/// Lumen's structural tokens configuration.
/// Languages define this entirely - not known to framework.
pub fn tokens() -> StructuralTokens {
    StructuralTokens {
        newline: NEWLINE,
        indent: INDENT,
        dedent: DEDENT,
        eof: EOF,
    }
}

// --------------------
// Indentation Processing
// --------------------

/// Post-process raw tokens to add indentation-based tokens.
/// Takes tokens from framework lexer (no INDENT/DEDENT/NEWLINE/EOF)
/// and produces final token stream for Lumen (with all structural tokens).
pub fn process_indentation(source: &str, raw_tokens: Vec<SpannedToken>) -> LumenResult<Vec<SpannedToken>> {
    let mut out = Vec::new();
    let mut indents = vec![0usize];
    let mut line_no = 1usize;

    for raw in source.lines() {
        // Count leading spaces
        let mut spaces = 0usize;
        for ch in raw.chars() {
            if ch == ' ' {
                spaces += 1;
            } else {
                break;
            }
        }

        let rest = &raw[spaces..];

        // Skip blank / whitespace-only lines (do not emit NEWLINE)
        if rest.trim().is_empty() {
            line_no += 1;
            continue;
        }

        // Indentation handling (4-space indents for Lumen)
        let current = *indents.last().unwrap();
        if spaces > current {
            if (spaces - current) % 4 != 0 {
                return Err(format!("Invalid indentation at line {line_no}"));
            }
            indents.push(spaces);
            out.push(SpannedToken {
                tok: Token::Feature(INDENT),
                line: line_no,
                col: 1,
            });
        } else if spaces < current {
            while *indents.last().unwrap() > spaces {
                indents.pop();
                out.push(SpannedToken {
                    tok: Token::Feature(DEDENT),
                    line: line_no,
                    col: 1,
                });
            }
            if *indents.last().unwrap() != spaces {
                return Err(format!("Indentation mismatch at line {line_no}"));
            }
        }

        // Add tokens from this line (from raw_tokens filtered by line number)
        for raw_tok in &raw_tokens {
            if raw_tok.line == line_no {
                out.push(raw_tok.clone());
            }
        }

        // Add NEWLINE at end of line
        out.push(SpannedToken {
            tok: Token::Feature(NEWLINE),
            line: line_no,
            col: spaces + rest.len() + 1,
        });

        line_no += 1;
    }

    // Generate remaining DEDENT tokens
    while indents.len() > 1 {
        indents.pop();
        out.push(SpannedToken {
            tok: Token::Feature(DEDENT),
            line: line_no,
            col: 1,
        });
    }

    // Add EOF token
    out.push(SpannedToken {
        tok: Token::Feature(EOF),
        line: line_no,
        col: 1,
    });

    Ok(out)
}

// --------------------
// Registration
// --------------------

pub fn register(reg: &mut Registry) {
    // Register Lumen's operator tokens
    // Parentheses as single-char operators
    reg.tokens.add_single_char('(', LPAREN);
    reg.tokens.add_single_char(')', RPAREN);

    // Note: NEWLINE, INDENT, DEDENT, EOF tokens are generated by process_indentation()
    // and passed to parser via structural tokens config.
    // Framework no longer needs to know about them!
}
