# value_to_string.lm
# String conversion and formatting utilities for all value types
# Includes type introspection, canonical string representation, and base conversion

## Kind predicates
# Returns true if x has INTEGER kind
fn is_int(x)
    return kind(x) == INTEGER

# Returns true if x has RATIONAL kind
fn is_rational(x)
    return kind(x) == RATIONAL

# Returns true if x has REAL kind
fn is_real(x)
    return kind(x) == REAL

# Returns true if x has BOOLEAN kind
fn is_bool(x)
    return kind(x) == BOOLEAN

# Returns true if x has STRING kind
fn is_string(x)
    return kind(x) == STRING

# Returns true if x has ARRAY kind
fn is_array(x)
    return kind(x) == ARRAY

# Returns true if x has NULL kind
fn is_null(x)
    return kind(x) == NULL

# Convert a KIND meta-value to its canonical uppercase string representation
fn kind_to_string(k)
    if is_int(k)
        return "INTEGER"
    if is_rational(k)
        return "RATIONAL"
    if is_real(k)
        return "REAL"
    if is_bool(k)
        return "BOOLEAN"
    if is_string(k)
        return "STRING"
    if is_array(k)
        return "ARRAY"
    if is_null(k)
        return "NULL"
    error("kind_to_string: expected KIND meta-value")

# Convert any value to its canonical string representation
fn value_to_string(x)
    if is_int(x)
        return int_to_string(x)
    if is_rational(x)
        return rational_to_string(x)
    if is_real(x)
        return real_to_string(x)
    if is_bool(x)
        return bool_to_string(x)
    if is_string(x)
        return x
    if is_array(x)
        return array_to_string(x)
    if is_null(x)
        return null_to_string(x)
    error("value_to_string: unsupported value")

# ------------------------------------------------------------
# Base conversion utilities
# ------------------------------------------------------------

alphabet = "0123456789abcdefghijklmnopqrstuvwxyz"

# Convert integer/rational/real to a string in the given base (2..36).
fn numeric_to_base_string(value, radix)
    if not is_int(radix)
        error("numeric_to_base_string(): radix must be INTEGER")

    if radix < 2 or radix > 36
        error("numeric_to_base_string(): radix must be between 2 and 36")

    if is_int(value)
        return integer_to_base_string(value, radix)

    if is_rational(value)
        return rational_to_base_string(value, radix)

    if is_real(value)
        return real_to_base_string_default(value, radix)

    error("numeric_to_base_string(): unsupported kind: " . kind_to_string(kind(value)))

# Base conversion for integers.
fn integer_to_base_string(n, radix)
    if n == 0
        return "0"

    negative = false
    if n < 0
        negative = true
        n = -n

    result = ""

    while n > 0
        digit = n % radix
        result = char_at(alphabet, digit) . result
        n = n // radix      # integer quotient operator

    if negative
        result = "-" . result

    int_to_string(radix) . "@" . result

# Base conversion for rationals (numerator/denominator).
fn rational_to_base_string(r, radix)
    n = num(r)
    d = den(r)

    n_str = integer_to_base_string(n, radix)
    d_str = integer_to_base_string(d, radix)

    n_str . "/" . d_str

# Base conversion for reals with specified fractional precision.
fn real_to_base_string(value, radix, precision)
    i = int(value)
    f = frac(value)

    int_part = integer_to_base_string(i, radix)

    if f == 0
        return int_part

    frac_part = frac_to_base_string(f, radix, precision)

    int_part . "." . frac_part

# Base conversion for reals with default fractional precision.
fn real_to_base_string_default(value, radix)
    real_to_base_string(value, radix, REAL_DEFAULT_PRECISION)

# Fractional helper used by real_to_base_string.
fn frac_to_base_string(f, radix, limit)
    result = ""
    count = 0

    while count < limit
        if f == real_default(0)
            return result

        f = f * real_default(radix)
        digit = int(f)
        result = result . char_at(alphabet, digit)
        f = frac(f)
        count = count + 1

    result
