# parse_value.lm
# Parse string representations back into numeric values
# Supports base-prefixed format and plain decimal format

alphabet = "0123456789abcdefghijklmnopqrstuvwxyz"

# Main entry point: parse a string into its numeric value
fn string_to_value(s)
    if len(s) == 0
        error("string_to_value(): empty string")

    # Look for base prefix (radix@...)
    at_index = find_char(s, "@")

    if at_index >= 0
        # Extract radix from prefix
        radix_str = substring(s, 0, at_index)
        radix = parse_decimal_int(radix_str)

        if radix < 2 or radix > 36
            error("string_to_value(): radix must be between 2 and 36")

        # Extract value part after @
        value_str = substring(s, at_index + 1, len(s))

        # Parse the value in the given base
        parse_value_in_base(value_str, radix)
    else
        # No base prefix - parse as decimal (base 10)
        parse_value_in_base(s, 10)

# Parse a value string in the given base
# Handles integers, rationals (with /), and reals (with .)
fn parse_value_in_base(s, radix)
    if len(s) == 0
        error("parse_value_in_base(): empty string")

    # Check for division (rational)
    slash_index = find_char(s, "/")
    if slash_index >= 0
        # Parse as rational: numerator/denominator
        num_str = substring(s, 0, slash_index)
        den_str = substring(s, slash_index + 1, len(s))

        numerator = parse_integer_in_base(num_str, radix)
        denominator = parse_integer_in_base(den_str, radix)

        return numerator / denominator

    # Check for decimal point (real)
    dot_index = find_char(s, ".")
    if dot_index >= 0
        # Parse as real: integer_part.fractional_part
        int_str = substring(s, 0, dot_index)
        frac_str = substring(s, dot_index + 1, len(s))

        int_part = parse_integer_in_base(int_str, radix)
        frac_value = parse_fraction_in_base(frac_str, radix)

        # Convert to real
        combined = real_default(int_part) + frac_value
        return combined

    # Parse as integer
    parse_integer_in_base(s, radix)

# Parse an integer from a string in the given base
fn parse_integer_in_base(s, radix)
    if len(s) == 0
        error("parse_integer_in_base(): empty string")

    result = 0
    i = 0
    negative = false

    # Check for negative sign
    first_char = char_at(s, 0)
    if first_char == "-"
        negative = true
        i = 1

    # Parse digits
    while i < len(s)
        ch = char_at(s, i)
        digit_value = char_to_digit(ch, radix)

        if digit_value < 0 or digit_value >= radix
            error("parse_integer_in_base(): invalid digit '" . ch . "' for base " . int_to_string(radix))

        result = result * radix + digit_value
        i = i + 1

    if negative
        -result
    else
        result

# Parse fractional part of a real number in the given base
# Returns a real value between 0 and 1
fn parse_fraction_in_base(s, radix)
    if len(s) == 0
        return real_default(0)

    result = real_default(0)
    divisor = real_default(radix)
    i = 0

    while i < len(s)
        ch = char_at(s, i)
        digit_value = char_to_digit(ch, radix)

        if digit_value < 0 or digit_value >= radix
            error("parse_fraction_in_base(): invalid digit '" . ch . "' for base " . int_to_string(radix))

        result = result + real_default(digit_value) / divisor
        divisor = divisor * real_default(radix)
        i = i + 1

    result

# Parse a simple decimal integer (for parsing the radix prefix)
fn parse_decimal_int(s)
    parse_integer_in_base(s, 10)

# Convert a character to its digit value in the given base
# Returns -1 if invalid
fn char_to_digit(ch, radix)
    # Convert to lowercase for comparison
    ch_lower = to_lower(ch)

    # Find position in alphabet
    i = 0
    while i < len(alphabet)
        if char_at(alphabet, i) == ch_lower
            return i
        i = i + 1

    -1

# Convert a character to lowercase
fn to_lower(ch)
    code = ord(ch)

    # ASCII uppercase A-Z is 65-90, lowercase a-z is 97-122
    if code >= 65 and code <= 90
        chr(code + 32)
    else
        ch

# Find the first occurrence of a character in a string
# Returns index or -1 if not found
fn find_char(s, ch)
    i = 0
    while i < len(s)
        if char_at(s, i) == ch
            return i
        i = i + 1

    -1

# Extract substring from start index to end index (exclusive)
fn substring(s, start, end)
    if start < 0 or end > len(s) or start > end
        error("substring(): invalid range")

    result = ""
    i = start
    while i < end
        result = result . char_at(s, i)
        i = i + 1

    result
