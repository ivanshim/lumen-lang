# Convert a character into its numeric digit value (0–35), or -1 if invalid
fn digit_value(c)
    if is_digit(c)
        return ord(c) - ord("0")

    code = ord(c)

    # Uppercase A-Z
    if code >= ord("A") and code <= ord("Z")
        return (code - ord("A")) + 10

    # Lowercase a-z
    if code >= ord("a") and code <= ord("z")
        return (code - ord("a")) + 10

    return -1


# Parse a contiguous run of base-N digits and return [value, scale, new_index]
fn parse_digits(s, i, base)
    value = 0
    scale = 1

    while i < len(s)
        c = char_at(s, i)
        d = digit_value(c)

        if d < 0 or d >= base
            break

        value = value * base + d
        scale = scale * base
        i = i + 1

    return [value, scale, i]


# Parse a full numeric literal (base, integer, fraction, exponent) and return [result_value, new_index]
fn parse_number(s, i)
    start = i
    base_prefix = 0

    # leading base-10 digits (base or value prefix)
    while i < len(s)
        c = char_at(s, i)
        if not is_digit(c)
            break
        base_prefix = base_prefix * 10 + (ord(c) - ord("0"))
        i = i + 1

    # no digits → not a number
    if i == start
        return [0, start]

    base = 10
    result_value = base_prefix
    has_base_prefix = false

    # optional base reassignment
    if i < len(s) and char_at(s, i) == "@"
        base = base_prefix
        has_base_prefix = true
        if base < 2 or base > 36
            error("invalid base")

        i = i + 1
        r = parse_digits(s, i, base)
        result_value = r[0]
        i = r[2]

    # optional fractional part
    if i < len(s) and char_at(s, i) == "."
        i = i + 1
        r2 = parse_digits(s, i, base)
        frac_val = r2[0]
        frac_scale = r2[1]
        i = r2[2]

        if frac_scale > 1
            result_value = result_value + frac_val / frac_scale

    # optional exponent
    if i < len(s) and char_at(s, i) == "^"
        i = i + 1
        r3 = parse_digits(s, i, base)
        exp = r3[0]
        i = r3[2]

        # If no base prefix (@), compute result_value^exp
        # If has base prefix, compute result_value * base^exp (scientific notation)
        if has_base_prefix
            pow = 1
            j = 0
            while j < exp
                pow = pow * base
                j = j + 1
            result_value = result_value * pow
        else
            # Compute result_value^exp
            result_pow = 1
            k = 0
            base_for_power = result_value
            while k < exp
                result_pow = result_pow * base_for_power
                k = k + 1
            result_value = result_pow

    return [result_value, i]


# Convert a string into a numeric value or return the original string if parsing fails
fn string_to_value(s)
    if len(s) == 0
        return 0

    i = 0

    # parse numerator
    r = parse_number(s, i)
    num = r[0]
    i = r[1]

    # optional rational denominator
    if i < len(s) and char_at(s, i) == "/"
        i = i + 1
        if i == len(s)
            return s

        r2 = parse_number(s, i)
        denom = r2[0]
        i = r2[1]

        if i != len(s)
            return s

        return num / denom

    if i == len(s)
        return num

    return s
