# Convert a character into its numeric digit value (0–35), or -1 if invalid
fn character_to_value(c)
    if is_digit(c)
        return ord(c) - ord("0")

    code = ord(c)
    if code >= ord("A") and code <= ord("Z")
        return code - ord("A") + 10

    if code >= ord("a") and code <= ord("z")
        return code - ord("a") + 10

    -1


# Parse a contiguous run of base-N digits and return [value, scale, new_index]
fn digits_to_base_value(s, i, base)
    start = i
    value = 0
    scale = 1

    while i < len(s)
        c = char_at(s, i)
        d = character_to_value(c)

        if d < 0 or d >= base
            break

        value = value * base + d
        scale = scale * base
        i = i + 1

    # ERROR only if no digits were consumed
    if i == start
        error("expected digit")

    [value, scale, i]


# Parse a full numeric literal (base, integer, fraction, exponent) and return [value, new_index]
fn numeric_literal_to_value(s, i)
    start = i
    base_prefix = 0

    # leading base-10 digits (base or value prefix)
    while i < len(s)
        c = char_at(s, i)
        if not is_digit(c)
            break
        base_prefix = base_prefix * 10 + (ord(c) - ord("0"))
        i = i + 1

    # no digits → not a number
    if i == start
        return [0, start]

    base = 10
    value = base_prefix

    # optional base reassignment
    if i < len(s) and char_at(s, i) == "@"
        base = base_prefix
        if base < 2 or base > 36
            error("invalid base")

        i = i + 1
        r = digits_to_base_value(s, i, base)
        value = r[0]
        i = r[2]

    # optional fractional part
    if i < len(s) and char_at(s, i) == "."
        i = i + 1
        r2 = digits_to_base_value(s, i, base)
        frac_val = r2[0]
        frac_scale = r2[1]
        i = r2[2]

        if frac_scale > 1
            value = value + frac_val / frac_scale

    # optional exponent (value-aware)
    if i < len(s) and char_at(s, i) == "^"
        i = i + 1
        r3 = digits_to_base_value(s, i, base)
        exp = r3[0]
        i = r3[2]

        pow = 1
        j = 0
        while j < exp
            pow = pow * value
            j = j + 1

        value = pow

    [value, i]


# Convert a string into a numeric value or return the original string if parsing fails
fn string_to_value(s)
    if len(s) == 0
        return 0

    i = 0

    # parse numerator
    r = numeric_literal_to_value(s, i)
    num = r[0]
    i = r[1]

    # optional rational denominator
    if i < len(s) and char_at(s, i) == "/"
        i = i + 1
        if i == len(s)
            return s

        r2 = numeric_literal_to_value(s, i)
        denom = r2[0]
        i = r2[1]

        if i != len(s)
            return s

        return num / denom

    if i == len(s)
        return num

    s
