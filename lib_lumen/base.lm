alphabet = "0123456789abcdefghijklmnopqrstuvwxyz"

# Convert integer/rational/real to a string in the given base (2..36)
fn base(value, radix)
    if kind(radix) != INTEGER
        error("base(): radix must be INTEGER")

    if radix < 2 or radix > 36
        error("base(): radix must be between 2 and 36")

    k = kind(value)

    if k == INTEGER
        return base_integer(value, radix)

    if k == RATIONAL
        return base_rational(value, radix)

    if k == REAL
        return base_real(value, radix)

    error("base(): unsupported kind: " . str(k))

# Base conversion for integers
fn base_integer(n, radix)
    if n == 0
        return "0"

    negative = false
    if n < 0
        negative = true
        n = -n

    result = ""

    while n > 0
        digit = n % radix
        result = char_at(alphabet, digit) . result
        n = n // radix      # integer quotient operator

    if negative
        result = "-" . result

    result

# Base conversion for rationals (numerator/denominator)
fn base_rational(r, radix)
    n = num(r)
    d = den(r)

    n_str = base_integer(n, radix)
    d_str = base_integer(d, radix)

    n_str . "/" . d_str

# Base conversion for reals with fixed fractional precision
fn base_real(x, radix)
    i = int(x)
    f = frac(x)

    int_part = base_integer(i, radix)

    if f == 0
        return int_part

    frac_part = base_frac(f, radix, 16)

    int_part . "." . frac_part

# Fractional helper used by base_real
fn base_frac(f, radix, limit)
    result = ""
    count = 0

    while count < limit
        if f == real_default(0)
            return result

        f = f * real_default(radix)
        digit = int(f)
        result = result . char_at(alphabet, digit)
        f = frac(f)
        count = count + 1

    result
